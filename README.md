# EscapeAnalysisTree
逃逸技术研究


<pre>
逃逸分析

         分析对象的动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用。
</pre>

<pre>
对象栈上分配：
            Java对象是在堆上分配的，而垃圾回收机制会回收堆中不再使用的对象，但是筛选出
      可回收对象，回收对象还有整理内存都需要消耗时间。
            如果能够通过逃逸分析确定某些对象不会逃出方法之外，那就可以让这个对象在栈上
      分配内存，这样该对象锁占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。

            在一般应用中，如果不会逃逸的局部对象所占的比例比较大，如果能使用栈上分配，那
      大量的对象就会随着方法的结束而自动销毁。
</pre>

<pre>
            Java虚拟机中的原始数据类型(int, long等)都不能进一步分解，他们就可以称为标量。
      相对的，如果一个数据可以继续分解，那它就是聚合量，Java中最典型的聚合量就是对象。如果
      逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将
      可能不会创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。拆散后的
      变量便可以被单独分析和优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需
      在堆上整体分配空间了。
</pre>

<pre>
            逃逸分析有时间消耗，所以性能未必提升多少，并且由于逃逸分析比价耗时，目前的实现
      采用不那么准确但是时间压力相对较小的算法来完成逃逸分析，这就可能导致效果不稳定，要慎用。
            
            HotSpot做逃逸分析比较复杂，但是还不支持逃逸分析技术。
</pre>